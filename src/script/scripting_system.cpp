#define TINYDIR_USE_READDIR_R 0
#include <easylogging++.h>
#include <tinydir.h>
#include <regex>
#include <cctype>
#include <chaiscript/chaiscript_stdlib.hpp>
#include "scripting_system.h"
#include "generated/generated_registrations.h"
#include "glm_registrations.h"

namespace Script {

  ScriptingSystem::ScriptingSystem(const std::string scripts_location) : scripts_location(scripts_location) {
    chai = std::make_shared<chaiscript::ChaiScript>();

    chai->add(getGlmModule());
    
    //Register modules that were generated by the script registration generator
    try {
      generated::registerModules(chai);
    } catch(std::exception& e) {
      LOG(INFO)<<e.what();
    }
  }

  std::string ScriptingSystem::filenameToTitleCase(std::string s) {
    std::string new_string = s;

    //drop full location specification
    auto last_slash = new_string.rfind('/');

    new_string.erase(0, last_slash + 1);

    //drop file extension
    new_string.erase(new_string.find('.'));

    new_string[0] = toupper(new_string[0]);

    while(new_string.find('_') != std::string::npos) {
      auto pos = new_string.find('_');
      new_string[pos+1] = toupper(new_string[pos+1]);
      new_string.erase(pos, 1);
    }

    return new_string;
  }

  void ScriptingSystem::registerModule(chaiscript::ModulePtr module) {
    chai->add(module);
  }

  void ScriptingSystem::loadScript(const std::string& name) {
    LOG(INFO)<<"Loading script: "<<name;

    try {
      chai->use(name);
    } catch(chaiscript::exception::eval_error e) {
      std::stringstream error;
      error << "File: "<<e.filename<<" eval error at ("<<e.start_position.line<<", "<<e.start_position.column<<"): "<<e.reason;
      LOG(INFO)<<error.str();
    }

    auto class_name = filenameToTitleCase(name);

    auto script = std::make_shared<ScriptObject>(class_name, chai);

    scripts.push_back(script);
    LOG(INFO)<<"Added scripting class: "<<class_name;
  }

  std::vector<std::string> ScriptingSystem::getFileList(const std::string& location) {
    std::vector<std::string> files;

    tinydir_dir dir;
    tinydir_open(&dir, location.c_str());

    while(dir.has_next) {
      tinydir_file file;
      tinydir_readfile(&dir, &file);

      std::regex chai_match("[^[:space:]]+[.]chai");

      if(!file.is_dir && std::regex_match(std::string(file.name), chai_match) ) {
        files.push_back(std::string(location + file.name));
      }
      else if(file.is_dir && std::string(file.name) != "." && std::string(file.name) != "..") {
        auto dir_files = getFileList(location + file.name + "/");
        files.insert(files.end(), dir_files.begin(), dir_files.end());
      }

      tinydir_next(&dir);
    }

    return files;
  }

  void ScriptingSystem::loadScripts() {
    for(auto file : getFileList(scripts_location)) {
      loadScript(file);
    }

    for(auto script1 : scripts) {
      for(auto script2 : scripts) {
        if(script1 != script2) {
          script1->addObserver(script2);
          script2->addObserver(script1);
        }
      }
    }
  }

  void ScriptingSystem::start() {
    chai->add(chaiscript::bootstrap::standard_library::map_type<std::map<std::shared_ptr<Game::Scene>, bool>>("SceneMap"));
    chai->add(chaiscript::bootstrap::standard_library::vector_type<std::vector<std::string>>("StringVector"));
    for(auto script : scripts) {
      try {
        script->onStart();
      } 
      catch (const chaiscript::exception::eval_error &ee) {
        std::stringstream s;
        s << ee.what();
        if (ee.call_stack.size() > 0) {
          s << "during evaluation at (" << ee.call_stack[0]->start().line << ", " << ee.call_stack[0]->start().column << ")";
        }
        s << '\n';
        LOG(INFO)<<s.str();
      }
    }

  }

  void ScriptingSystem::update(const float delta) {
    for(auto script : scripts) {
      try {
        script->onUpdate(delta);
      } catch(chaiscript::exception::eval_error e) {
        std::stringstream error;
        error << "Error During on update, File: "<<e.filename<<" eval error at ("<<e.start_position.line<<", "<<e.start_position.column<<"): "<<e.reason;
        LOG(INFO)<<error.str();
      }
    }
  }

  void ScriptingSystem::destroy() {
    for(auto script : scripts) {
      try {
        script->onDestroy();
      } catch(chaiscript::exception::eval_error e) {
        std::stringstream error;
        error << "Error During on destroy, File: "<<e.filename<<" eval error at ("<<e.start_position.line<<", "<<e.start_position.column<<"): "<<e.reason;
        LOG(INFO)<<error.str();
      }
    }
  }
}